use serde::{Deserialize, Serialize};
use uuid::Uuid;

const LOCATION_STALE_THRESHOLD_SECS: i64 = 60;
#[derive(Debug, Clone)]
pub enum RideStatus {
    None,
    Assigned,
    InRide,
    Completed,
    Canceled,
}

impl ToString for RideStatus {
    fn to_string(&self) -> String {
        match self {
            RideStatus::None => "none",
            RideStatus::Assigned => "assigned",
            RideStatus::InRide => "in_ride",
            RideStatus::Completed => "completed",
            RideStatus::Canceled => "canceled",
        }
        .to_string()
    }
}

impl RideStatus {
    pub fn from_str(s: &str) -> Self {
        match s {
            "assigned" => RideStatus::Assigned,
            "in_ride" => RideStatus::InRide,
            "completed" => RideStatus::Completed,
            "canceled" => RideStatus::Canceled,
            _ => RideStatus::None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct DriverStatus {
    pub driver_id: Uuid,
    pub driver_available: bool,
    pub ride_status: RideStatus,
    pub current_trip_id: Option<Uuid>,
    pub status_updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Deserialize)]
pub(crate) struct DriverRedisState {
    available: String, // or bool/i32 depending on your schema
    last_updated: i64,
    last_location_ts: i64,
    driver_online: String,
    in_ride: String,
    ride_id: String,
    reason: String,
}

pub struct Availability {
    pub available: bool,
    pub reason: AvailabilityReason,
    pub last_updated: i64,
}

#[derive(Debug, Clone, PartialEq)]
pub enum AvailabilityReason {
    OfflineToggle,
    InRide,
    StaleLocation,
    Available,
    RideAssigned,
}

impl ToString for AvailabilityReason {
    fn to_string(&self) -> String {
        match self {
            AvailabilityReason::OfflineToggle => "offline_toggle",
            AvailabilityReason::InRide => "in_ride",
            AvailabilityReason::StaleLocation => "stale_location",
            AvailabilityReason::Available => "available",
            AvailabilityReason::RideAssigned => "ride_assigned",
        }
        .to_string()
    }
}

// this was generated by gpt
// todo this might need a heartbeat mechanism separate from location updates will see
/// Compute availability from the given driver state
/// Computes availability status based on DriverState.
pub fn compute_availability(now: i64, s: &DriverRedisState) -> Availability {
    // Convert Redis-style fields to bools.
    let is_online = s.driver_online == "1";
    let is_in_ride = s.in_ride == "1";

    // 1) in_ride overrides everything
    if is_in_ride {
        return Availability {
            available: false,
            reason: AvailabilityReason::InRide,
            last_updated: now,
        };
    }

    // 2) explicit offline toggle
    if !is_online {
        return Availability {
            available: false,
            reason: AvailabilityReason::OfflineToggle,
            last_updated: now,
        };
    }

    // 3) stale location -- this should translate as offline in business logic
    if now - s.last_location_ts > LOCATION_STALE_THRESHOLD_SECS {
        return Availability {
            available: false,
            reason: AvailabilityReason::StaleLocation,
            last_updated: now,
        };
    }

    // Otherwise, available!
    Availability {
        available: true,
        reason: AvailabilityReason::Available,
        last_updated: now,
    }
}

#[derive(Debug, Clone)]
pub struct Driver {
    pub id: Uuid,
    pub name: String,
    pub license_number: Option<String>, // might not be known at time of creation
    pub rating: Option<f32>,            // not known at time of creation
    pub car_id: Option<Uuid>,           // might not be assigned at creation
}

#[derive(Debug, Clone)]
pub struct Vehicle {
    pub id: Uuid,
    pub make: String,
    pub model: String,
    pub plate_number: String,
    pub year: u16,
    pub driver_id: Uuid, // Foreign key to Driver
}

#[derive(Debug, Clone)]
pub struct DriverLocation {
    pub driver_id: i32,
    pub latitude: f64,
    pub longitude: f64,
    pub timestamp: chrono::NaiveDateTime,
}

// optional later: Add models for DriverScedule (if you want planned shifts for later), DriverEarnings, DriverPrerferences(max distance, max time, etc.)
